# --- Toolchain Definition ---
CROSS_COMPILE = arm-none-eabi-
CC      = $(CROSS_COMPILE)gcc
LD      = $(CROSS_COMPILE)ld
OBJCOPY = $(CROSS_COMPILE)objcopy

# --- Project Layout ---
INC_DIR = include
OBJ_DIR = obj
BIN_DIR = bin


# --- Linker File ---
LINKER  = arch/arm/linker.ld

# --- Flags ---
CPU     = -mcpu=cortex-a15
ARCH    = -marm
# -MMD generates dependency files (.d)
# -Wall -Wextra: Don't be lazy, catch your mistakes at compile time
CFLAGS  = $(CPU) $(ARCH) -g -O0 -ffreestanding -nostdlib \
          -I$(INC_DIR) -Wall -Wextra -MMD -MP
ASFLAGS = $(CPU) $(ARCH)

# --- Source Discovery ---
# This finds all .c and .S files in your src subdirectories
SRCS_C  = $(shell find kernel lib arch -name '*.c')
SRCS_S  = $(shell find arch -name '*.[sS]')

# Transform src/xxx.c into obj/xxx.o
OBJS		= $(patsubst %.c, $(OBJ_DIR)/%.o, $(SRCS_C)) \
					$(patsubst %.s, $(OBJ_DIR)/%.o, $(filter %.s, $(SRCS_S))) \
					$(patsubst %.S, $(OBJ_DIR)/%.o, $(filter %.S, $(SRCS_S)))

DEPS    = $(OBJS:.o=.d)

# --- Targets ---
TARGET  = $(BIN_DIR)/xinu.elf

.PHONY: all clean

all: $(TARGET)

$(TARGET): $(OBJS) | $(BIN_DIR)
	@echo "LINKING $@"
	$(CC) $(CFLAGS) -T $(LINKER) $(OBJS) -o $@ -lgcc

# Pattern rule for C files
$(OBJ_DIR)/%.o: %.c | $(OBJ_DIR)
	@mkdir -p $(dir $@)
	$(CC) $(CFLAGS) -c $< -o $@

# Pattern rule for Assembly files
$(OBJ_DIR)/%.o: %.S | $(OBJ_DIR)
	@mkdir -p $(dir $@)
	$(CC) $(ASFLAGS) -c $< -o $@

$(OBJ_DIR)/%.o: %.s | $(OBJ_DIR)
	@mkdir -p $(dir $@)
	$(CC) $(ASFLAGS) -c $< -o $@

$(OBJ_DIR) $(BIN_DIR):
	mkdir -p $@

clean:
	rm -rf $(OBJ_DIR) $(BIN_DIR)

# Include the dependency files generated by -MMD
-include $(DEPS)


# --- QEMU Configuration ---
QEMU = qemu-system-arm
QFLAGS = -M virt -cpu cortex-a15 -nographic -serial mon:stdio

# --- Execution Targets ---
.PHONY: run debug

run: $(TARGET)
	$(QEMU) $(QFLAGS) -kernel $(TARGET)

# Starts QEMU but halts the CPU until GDB connects
debug: $(TARGET)
	$(QEMU) $(QFLAGS) -S -s -kernel $(TARGET)
